	Â¥HÂ¤WÂªÂºÂ¤Ã¥Â¦rÂ±NÂ·|Â¤Â¶Â²ÃÂ¦pÂ¦Ã³Â¬Â° Merc Â¼WÂ¥[Â¤@Â­Ã“Ã‚Â²Â³Ã¦ÂªÂº QUEST Â¥\Â¯Ã Â¡C
	Â¥Â¦Â­Ã¬Â©lÂªÂºÂ·QÂªkÂ¬OÂ§QÂ¥Ã mob program Â¨Ã“Â´Ã€ player Â³]Â©wÂ¤@Â¨Ã‡ markÂ¡C
	Ã‚Ã‡Â¥Ã‘Â¹Ã¯ mark ÂªÂºÃ€Ã‹Â¬dÂ¨Ã“Â¹FÂ¨Ã¬Â°OÂ¿Ã½ QUEST Â§Â¹Â¦Â¨Â«Ã—ÂªÂºÂ¥\Â¯Ã Â¡C
	
	Â­ÂºÂ¥Ã½Â¦bÂ§AÂªÂº Makefile Â¤Â¤Â¥[Â¤W quest.c Â¤ÂºÂ®eÂ¦pÂ¤UÂ¡G

#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include "merc.h"

#if !defined(macintosh)
extern	int	_filbuf		args( (FILE *) );
#endif

QMARK *qmark_free;

void set_qmark( CHAR_DATA *victim, char *arg )
{
    QMARK *qmark;

    if( qmark_free == NULL )
        qmark = alloc_perm( sizeof(*qmark) );
    else
    {
        qmark = qmark_free;
        qmark_free = qmark_free->next;
    }
    qmark->next = victim->pcdata->quest_mark;
    victim->pcdata->quest_mark = qmark;
    smash_tilde( arg );
    qmark->mark = str_dup( arg);
    return;
}

bool check_qmark( CHAR_DATA *victim, char *arg )
{
    QMARK *qmark,*qmark_next;

    for( qmark=victim->pcdata->quest_mark; qmark != NULL; qmark=qmark_next )
    {
        qmark_next = qmark->next;
        if( !str_cmp( qmark->mark , arg ) )
            return TRUE;
    }
    return FALSE;
}

bool del_qmark( CHAR_DATA *victim, char *arg )
{
    QMARK *qmark, *qmark_last, *qmark_next;

    qmark = victim->pcdata->quest_mark;

    if( !str_cmp( qmark->mark, arg ) )
    {
        free_string( qmark->mark );
        victim->pcdata->quest_mark = qmark->next;
        qmark->next = qmark_free;
        qmark_free = qmark;
    }
    else
    {
        qmark_last = qmark;
        for( qmark = qmark->next; qmark != NULL; qmark = qmark_next )
        {
            qmark_next = qmark->next;
            if( !str_cmp( qmark->mark, arg ) )
            {
    		free_string( qmark->mark );
    		qmark_last->next = qmark->next;
    		qmark->next = qmark_free;
    		qmark_free = qmark;            	
            }
            qmark_last = qmark;
        }
    }

    return TRUE;
}

/* Â®Ã¦Â¦Â¡: mpaddmark <victim> <mark> */
void do_mpadd_qmark( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_STRING_LENGTH];
    char arg2[MAX_STRING_LENGTH];
    char *pTmp;
    CHAR_DATA *victim;

    if ( !IS_NPC( ch ) )
    {
        send_to_char( "Â§AÂ·QÂ·FÂ¹Ã€?\n\r", ch );
	return;
    }
    pTmp = one_argument( argument, arg1);
    one_argument( pTmp, arg2 );
    if ( ( victim = get_char_room_any( ch, arg1 ) ) == NULL )
    {
	char buf[100];
	if( !str_cmp(arg1,"Â¬YÂ¤Â£ÂªÂ¾Â¦WÂ¤HÂªÂ«") )
           return; /* Â³oÂ¬OÂ¦]Â¬Â°Â¬ÃÂ¤Â£Â¨Â£Â¤~Â·|Â³oÂ¼Ã‹ Â¤Â£Â¬OÂ¥XÂ¿Ã¹*/
	
	sprintf( buf," BUG : MPADDMARK : no VICTIM %s !! mob %d",
	      arg1 , ch->pIndexData->vnum );
	bug( buf,0);
	return;
    }
    if ( arg2[0] == '\0' )
    {
	bug( " BUG : MPADDMARK : no MARK string !! mob %d ", ch->pIndexData->vnum );
	return;
    }
    if ( IS_NPC(victim) )
	return;
    if( check_qmark( victim, arg2 ) == FALSE )
        set_qmark( victim, arg2 );
}

/* Â®Ã¦Â¦Â¡: mpdelmark <victim> <mark> */
void do_mpdel_qmark( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_STRING_LENGTH];
    char arg2[MAX_STRING_LENGTH];
    char *pTmp;
    CHAR_DATA *victim;

    if ( !IS_NPC( ch ) )
    {
        send_to_char( "Â§AÂ·QÂ·FÂ¹Ã€?\n\r", ch );
	return;
    }
    pTmp = one_argument( argument, arg1);
    one_argument( pTmp, arg2 );
    if ( ( victim = get_char_room_any( ch, arg1 ) ) == NULL )
    {
        char buf[100];
        if( !str_cmp(arg1,"Â¬YÂ¤Â£ÂªÂ¾Â¦WÂ¤HÂªÂ«") )
            return; /* Â³oÂ¬OÂ¦]Â¬Â°Â¬ÃÂ¤Â£Â¨Â£Â¤~Â·|Â³oÂ¼Ã‹ Â¤Â£Â¬OÂ¥XÂ¿Ã¹*/

	sprintf(buf, " BUG : MPDELMARK : no VICTIM %s !! mob %d",
	         arg1,ch->pIndexData->vnum );
	bug( buf, 0);
	return;
    }
    if ( arg2[0] == '\0' )
    {
	bug( " BUG : MPDELMARK : no MARK string !! mob %d ",ch->pIndexData->vnum );
	return;
    }
    if ( IS_NPC(victim) )
	return;
    if( check_qmark( victim, arg2) == TRUE )
        del_qmark( victim, arg2 );
}

/* Â®Ã¦Â¦Â¡: is_qmark <victim> <opr> <mark> */
bool is_qmark( CHAR_DATA *victim, char* opr,char *mark )
{
    bool found;
    char arg[MAX_STRING_LENGTH];

    if( IS_NPC( victim ) )
        return FALSE;
    one_argument( mark, arg );
    found = check_qmark( victim, arg );

    if( !str_cmp( opr, "!=" ) )
        found = ((found == TRUE) ? FALSE : TRUE);
    else if( str_cmp( opr, "==" ) )
        bug("Is_qmark: bad opr .", 0 );
    return found;
}


	Â¦b merc.h Â¤Â¤Â©wÂ¸q:

typedef struct  quest_mark_data		QMARK;		

struct quest_mark_data
{
    QMARK *	next;
    char  *     mark;
};

extern QMARK * qmark_free;
DECLARE_DO_FUN( do_mpadd_qmark 	);
DECLARE_DO_FUN( do_mpdel_qmark 	);

void 	set_qmark	args( ( CHAR_DATA *victim, char *argument ) );
bool 	del_qmark	args( ( CHAR_DATA *victim, char *arg      ) );
bool 	check_qmark	args( ( CHAR_DATA *victim, char *arg      ) );
bool 	is_qmark	args( ( CHAR_DATA *victim, char* opr, char *mark ) );

	Â¶Ã¢....ÃÃ™Â¦Â³ merc.h Â¤Â¤ struc pc_data Â¤Â¤ Â¼WÂ¥[Â¤@Â­Ã“Ã„Ã¦Â¦Ã¬Â¡G

    QMARK *             quest_mark;	

        Â±ÂµÂµÃ›Â¦b mob_prog.c Â¤Â¤ÂªÂº bool mprog_do_ifchck() Â³oÂ­Ã“Â¨Ã§Â¦Â¡Â¤Â¤Â¦h
	Â¼WÂ¥[Â¤@Â­Ã“ str_cmpÂ¡G

  if ( !str_cmp( buf, "is_qmark" ) )
    {
      switch ( arg[1] )
        {
        case 'i': return 1;
        case 'n': if ( actor )
                     return is_qmark( actor, opr, val );
                  else return -1;
        case 't': if ( vict )
                     return is_qmark( vict, opr, val );
                  else return -1;
        case 'r': if ( rndm )
                     return is_qmark( rndm, opr, val );
                  else return -1;
        default:
          bug ("Mob: %d bad argument to 'is_qmark'", mob->pIndexData->vnum );
          return -1;
        }
    }	

	Â¦pÂªGÂ§AÂ§Ã†Â±Ã¦ mob Â¤]Â¯Ã Ã€Ã‹Â¬d player Â¨Â­Â¤WÂ±aÂ©ÃÂªÃŒÂ¬OÂ¸Ã‹Â³Ã†Â¬YÂªÂ«Â«~Â¡MÂ¥iÂ¥HÂ¦AÂ¥[
	Â¤WÂ³oÂ¨Ã¢Â­Ã“ str_cmpÂ¡G

  if ( !str_cmp( buf, "is_inv_obj" ) )
    {
      switch ( arg[1] )
        {
        case 'i': /* return 1; */
                  return is_inv_obj( mob, opr, val );
        case 'n': if ( actor )
                     return is_inv_obj( actor, opr, val );
                  else return -1;
        case 't': if ( vict )
                     return is_inv_obj( vict, opr, val );
                  else return -1;
        case 'r': if ( rndm )
                     return is_inv_obj( rndm, opr, val );
                  else return -1;
        default:
          bug ("Mob: %d bad argument to 'is_inv_obj'", mob->pIndexData->vnum );
          return -1;
        }
    }

  if ( !str_cmp( buf, "is_equ_obj" ) )
    {
      switch ( arg[1] )
        {
        case 'i': return is_equ_obj( mob, opr, val );
        case 'n': if ( actor )
                     return is_equ_obj( actor, opr, val );
                  else return -1;
        case 't': if ( vict )
                     return is_equ_obj( vict, opr, val );
                  else return -1;
        case 'r': if ( rndm )
                     return is_equ_obj( rndm, opr, val );
                  else return -1;
        default:
          bug ("Mob: %d bad argument to 'is_equ_obj'", mob->pIndexData->vnum );
          return -1;
        }
    }


	Â§OÂ§Ã‘Â¤FÂ¦b mob_prog.c ÂªÂºÂ«Ã¡Â­Â±Â¥[Â¤WÂ³oÂ¨Ã¢Â­Ã“Â¨Ã§Â¦Â¡Â¡MÂ¥HÂ¤ÃÂ¦b merc.h Â¤Â¤Â«Ã…
	Â§iÂ¡C

bool is_inv_obj (CHAR_DATA* ch, char* opr, char* val)
{
  OBJ_DATA* obj;
  int vnum;
  bool found;
  char topr[4];

  vnum = atoi(val);

  if( !str_cmp( opr, "!=" ) )
  {
      strcpy( topr, "!=" );
      strcpy( opr, "==" );
  }

  found = FALSE;
  for(obj = ch->carrying; obj != NULL ; obj = obj->next_content)
  {
      if( mprog_veval( obj->pIndexData->vnum, opr, vnum )
      &&   obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) )
      {
        found = TRUE;
        break;
      }
  }

  if( !str_cmp( topr, "!=" ) )
      return found == TRUE ? FALSE : TRUE;
  return found;
}

bool is_equ_obj (CHAR_DATA* ch, char* opr, char* val)
{
    OBJ_DATA* obj;
    int vnum;
    bool found;
    char topr[4];

    vnum = atoi(val);
    if( !str_cmp( opr, "!=" ) )
    {
        strcpy( topr, "!=" );
        strcpy( opr, "==" );
    }

    found = FALSE;
    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
    {
        if ( mprog_veval( obj->pIndexData->vnum, opr, vnum )
        &&   obj->wear_loc != WEAR_NONE && can_see_obj( ch, obj ) )
        {
             found = TRUE;
             break;
        }
    }

  if( !str_cmp( topr, "!=" ) )
       return found == TRUE ? FALSE : TRUE;
  return found;
}

	Â³oÂ¼Ã‹Â¤@Â¨Ã“Â´NÂ¥iÂ¥HÂ§QÂ¥Ã mob program Â¨Ã“Â»sÂ§@ quest Â¡C

	Â±ÂµÂµÃ›Â¤UÂ¨Ã“Â¬OÂ­nÂ¼WÂ¥[Â¤@Â­Ã“Â·sÂªÂº triggerÂ¡CÃ…Ã½ player Â¥iÂ¥HÂ©M mob talk
	Â¨Ã“Ã„Â²ÂµoÂ¡C

	Â¦b interp.c Â¤Â¤ÂªÂº cmd_table Â¤Â¤Â¼WÂ¥[Â¤@Â­Ã“Â·sÂªÂºÂ«Ã¼Â¥OÂ¡G

    { "talk",		do_talk,	POS_RESTING,	 0,  LOG_NORMAL	},	

	Â·Ã­ÂµMÂ¡MÂ¦b merc.h Â¤Â¤Â¤]Â­nÂ©wÂ¸qÂ¡G

DECLARE_DO_FUN(	do_talk		);

	Â¦Ã“Â§Ã¢ do_talk() Â³oÂ­Ã“Â¨Ã§Â¦Â¡Â¥[Â¦b act_comm.c Â·Ã­Â¤Â¤Â¡G

void do_talk( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    int position;

    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_SILENCE) )
    {
	send_to_char( "[32mÂ¤Ã‘Â¯Â«Â¤Â£Â²aÂ§AÂµoÂ¥XÂ¥Ã´ÃnÂ­Âµ![37m\n\r", ch );
	return;
    }

    argument = one_argument( argument, arg );

    if ( arg[0] == '\0'  )
    {
	send_to_char( "Â§AÂ­nÂ§iÂ¶DÂ¤Â°Â»Ã²Â¤HÂ¦Â³ÃƒÃ¶Â¤Â°Â»Ã²Â¨Ã†Â©O?\n\r", ch );
	return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL
    || ( victim->in_room != ch->in_room ) )
    {
	send_to_char( "Â§AÂ½ÃÂ¸ÃœÂªÂºÂ¹Ã¯Â¶HÂ²{Â¦bÂ¦nÂ¹Â³Â¤Â£Â¦b MUD Â¥@Â¬Ã‰Â¤Â¤Â³Ã¡!\n\r", ch );
	return;
    }

    if( !IS_NPC(victim) )
    {
        send_to_char("Â¥Ã tell Â²Ã¡Â¤Ã‘Â§a...\n\r",ch);
        return;
    }

    if ( !IS_AWAKE(victim) )
    {
	act( "$EÂºÃÂ±oÂ«ÃœÂ¼Ã´Â¦Ã“Ã…Â¥Â¤Â£Â¨Ã¬Â§AÂ»Â¡Â¤Â°Â»Ã².", ch, 0, victim, TO_CHAR );
	return;
    }

    if( argument[0] != '\0' )
    {
        act( "Â§AÂ©M $N Â¥Ã¦Â½Ã '$t'.", ch, argument, victim, TO_CHAR );
        position		= victim->position;
        victim->position	= POS_STANDING;
        act( "$cfyw$n$cfwe Â©MÂ§AÂ¥Ã¦Â½Ã '$t'.", ch, argument, victim, TO_VICT );
        victim->position	= position;
        victim->reply	= ch;
        mprog_talk_trigger(argument,ch,victim);
    }
    else
    {
        act( "Â§AÂ¸Ã•ÂµÃ›Â©M $N Â¥Ã¦Â½Ã....", ch, NULL, victim, TO_CHAR );
        position		= victim->position;
        victim->position	= POS_STANDING;
        act( "$cfyw$n$cfwe Â¸Ã•ÂµÃ›Â©MÂ§AÂ¥Ã¦Â½Ã.", ch, NULL, victim, TO_VICT );
        victim->position	= position;
        victim->reply	= ch;
        mprog_talk_trigger("topic",ch,victim);
    }
    return;
}

	Â§Â¹Â¦Â¨Â¤F talk Â³oÂ­Ã“Â«Ã¼Â¥OÂ«Ã¡Â¡MÂ«KÂ¬OÂ»sÂ§@ talk_triggerÂ¡C

	db.c Â¤Â¤ÂªÂº int mprog_name_to_type() Â¤Â¤Â¥[Â¤WÂ¤@Â¦Ã¦Â¡G

   if (!str_cmp(name,"talk_prog"))	return TALK_PROG;		

	mob_commands.c Â¤Â¤ÂªÂº char *mprog_type_to_name() Â¤Â¤Â¥[Â¤WÂ¤@Â¦Ã¦Â¡G

    case TALK_PROG:		return "talk_prog";	

	mob_prog.c Â¤Â¤Â¼WÂ¥[Â¡G

void mprog_talk_trigger( char *txt, CHAR_DATA *ch,CHAR_DATA *mob )
{
    MPROG_DATA *mprg;
    char arg[MAX_STRING_LENGTH];

    if( txt != NULL && !str_cmp(txt,"topic"))
    {
        for ( mprg = mob->pIndexData->mobprogs; mprg != NULL; mprg = mprg->next )
            if ( mprg->type & TALK_PROG )
            {
                one_argument(mprg->arglist, arg);
                if( arg[0] != '\0' && !str_cmp(arg,"topic") )
                    mprog_driver( mprg->comlist, mob, ch, NULL, NULL );
            }
        return;
    }

    if ( IS_NPC( mob ) && ( mob->pIndexData->progtypes & TALK_PROG ) )
      mprog_wordlist_check( txt, mob, ch, NULL, NULL, TALK_PROG );
    return;
}

	Â¨ÂºÂ³oÂ¼Ã‹Â´NÂ§Â¹Â¦Â¨Â¤FÂ¡CÂ¤UÂ­Â±Â¤Â¶Â²ÃÂ¤@Â¨Ã‡Â½dÂ¨Ã’Â¡G
	
	Â¦pÂªGÂ¦b mob program Â¤Â¤Â¼g talk_prog Â«Ã¡Â±Âµ topic ÂªÂºÂ¸ÃœÂ¡MÂªÃ­Â¥Ãœ player
	Â©M mob talkÂ¡MÂ«Ã¡Â­Â±Â¤Â£Â¥[Â¥Ã´Â¦Ã³Â¤ÃÂ¼Ã†Â¡CÂ¨Ã’Â¦p player Â¤UÂ¹FÂ³oÂ¼Ã‹ÂªÂºÂ«Ã¼Â¥OÂ¡J
	talk mobÂ¡
	Â´NÂ·|Â°ÃµÂ¦Ã¦Â¤UÂ­Â±ÂªÂº mob programÂ¡C
	
	
>talk_prog topic~
    ....
    ....
~

	Â¦pÂªGÂ¦b mob program Â¤Â¤Â¼g tlak_prog Â«Ã¡Â±ÂµÂ¤@Â­Ã“ p Â¥[Â¤WÂ¤@Â­Ã“Â¦rÂ¦ÃªÂªÂºÂ¸ÃœÂ¡MÂ¨Âº
	Â»Ã²Â·Ã­ player Â©M mob talk Â®Ã‰Â«Ã¡Â­Â±Â¥[Â¤WÂ¤ÃÂ¼Ã† "onething" ÂªÂºÂ¸ÃœÂ¡MÂ´NÂ·|Â°ÃµÂ¦Ã¦
	Â¤UÂ­Â±ÂªÂº mob programÂ¡CÂ¨Ã’Â¦pÂ«Ã¼Â¥OÂ¡J
	talk mob onething
	Â´NÂ·|Â°ÃµÂ¦Ã¦ mob program ÂªÂºÂ¤ÂºÂ®eÂ¡C
	
>talk_prog p onething~
    ....
    ....
~	

	Â¦ÃœÂ©Ã³ quest mark ÂªÂºÂ¥ÃÂªkÂ¡G

	mob Â¥iÂ¥HÂ§QÂ¥Ã mpadd_qmark Â¥HÂ¤Ã mpdel_qmark Â«Ã¼Â¥OÂ¨Ã“Â¬Â° player Â¼WÂ¥[
	quest markÂ¡CÂ¨Ã’Â¦pÂ¡G

        mpadd_qmark $n areaname_get_obj1

	Â¨ÂºÂ»Ã² player Â´NÂ·|Â¼WÂ¥[Â¤@Â­Ã“Â¥sÂ°Âµ areaname_get_obj1 ÂªÂº quest markÂ¡C
	Â¨Ã¤Â¤Â¤Â«Ã˜Ã„Â³Â¥HÂ©Â³Â½uÂ¨Ã“Â°ÃÂ¤Ã€Â¤@Â¨Ã‡Â³Ã¦Â¦rÂ¡MÂ¦Ã“Â²Ã„Â¤@Â­Ã“Â³Ã¦Â¦rÂ³ÃŒÂ¦nÂ©RÂ¦WÂ¬Â°Â°ÃÂ°Ã¬ÂªÂºÂ¦WÂºÃ™
	Â¡CÂ³oÂ¼Ã‹Â¤@Â¨Ã“Â¡MÂ°ÃÂ°Ã¬Â©MÂ°ÃÂ°Ã¬Â¤Â§Â¶Â¡Â©Ã’Â¨ÃÂ¥ÃÂªÂº quest mark Â´NÂ¤Â£Â·|Â¤Â¬Â¬Ã›Â­Â«Ã‚ÃÂ¡M
	Â¦Ã“ÂµoÂ¥ÃÂ°ÃÃƒDÂ¡C

	Â¦pÂªGÂ­nÃ€Ã‹Ã…Ã§ player Â¬OÂ§_Â¦Â³Â¬YÂ¤@Â­Ã“ quest mark Â¥iÂ¥HÂ§QÂ¥Ã if Â¨Ã“Â°ÂµÂ¨Ã¬Â¡C

	if is_qmark($n) == areaname_get_obj1

	Â¨ÂºÂ»Ã²Â·Ã­ player ÂªÂº quest mark Â¤Â¤Â§tÂ¦Â³ areaname_get_obj1 ÂªÂºÂ¸ÃœÂ¡MÂ´NÂ·|
	Â°ÃµÂ¦Ã¦ if Â¤ÂºÂªÂºÂ¤ÂºÂ®eÂ¡C

	Â§QÂ¥ÃÂ¥HÂ¤WÂ©Ã’Â¤Â¶Â²ÃÂªÂºÂ¤@Â¨Ã‡Â¤pÂµ{Â¦Â¡Â´NÂ¥iÂ¥HÂ«ÃœÃ‚Â²Â³Ã¦ÂªÂºÂ¹FÂ¨Ã¬Â¤@Â¨Ã‡ quest ÂªÂº
	Â­nÂ¨DÂ¡MÃÃ¶ÂµMÂ¤Â£Â¬OÂ«ÃœÂ§Â¹Â¾Ã£Â¡MÂ¦Ã½Â¬OÂ°ÂµÂ¬Â°Â°Ã²Ã‚Â¦ÂªÂºÃ€Â³Â¥ÃÃ€Â³Â¸Ã“Â´NÂ°Ã·Â¤FÂ¡C

	Â¦pÂªGÂ§AÂ¯Ã Â¬Â°Â§AÂªÂº mprog_do_ifchck Â¦hÂ¥[Â§Ã³Â¦hÂªÂºÂ¶ÂµÂ¥Ã˜Â¡MÂ¨ÂºÂ»Ã² mob program
	ÂªÂºÂ«Ã‚Â¤OÂ·|Â§Ã³Â¥[Â±jÂ¤jÂ¡C

